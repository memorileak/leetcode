use std::collections::VecDeque;

pub struct Solution;

#[allow(dead_code)]
impl Solution {
  // Traverse the grid, whenever we hit a 1,
  // start a BFS to explore and mark all connected 1s as visited.
  // To mark it as visited, we can set it to 0.
  // Each BFS trigger counts as one island.
  pub fn num_islands(grid: Vec<Vec<char>>) -> i32 {
    let m = grid.len();
    let n = grid[0].len();
    let mut g: Vec<char> = vec![];
    for mut r in grid.into_iter() {
      g.append(&mut r);
    }

    let mut islands: i32 = 0;
    for i in 0..g.len() {
      let c = g[i];
      if c == '1' {
        Self::bfs_explore(&mut g, m, n, i);
        islands += 1;
      }
    }

    islands
  }

  fn bfs_explore(g: &mut Vec<char>, m: usize, n: usize, i: usize) {
    let mut queue: VecDeque<usize> = VecDeque::new();
    queue.push_back(i);
    g[i] = '0';

    while !queue.is_empty() {
      let k = queue.pop_front().unwrap();

      // Above
      if k >= n {
        if g[k - n] == '1' {
          queue.push_back(k - n);
          g[k - n] = '0';
        }
      }

      // Below
      if k / n < (m - 1) {
        if g[k + n] == '1' {
          queue.push_back(k + n);
          g[k + n] = '0';
        }
      }

      // Left
      if k % n > 0 {
        if g[k - 1] == '1' {
          queue.push_back(k - 1);
          g[k - 1] = '0';
        }
      }

      // Right
      if k % n < (n - 1) {
        if g[k + 1] == '1' {
          queue.push_back(k + 1);
          g[k + 1] = '0';
        }
      }
    }
  }
}

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_example_1() {
    let grid = vec![
      vec!['1', '1', '1', '1', '0'],
      vec!['1', '1', '0', '1', '0'],
      vec!['1', '1', '0', '0', '0'],
      vec!['0', '0', '0', '0', '0'],
    ];
    assert_eq!(Solution::num_islands(grid), 1);
  }

  #[test]
  fn test_example_2() {
    let grid = vec![
      vec!['1', '1', '0', '0', '0'],
      vec!['1', '1', '0', '0', '0'],
      vec!['0', '0', '1', '0', '0'],
      vec!['0', '0', '0', '1', '1'],
    ];
    assert_eq!(Solution::num_islands(grid), 3);
  }

  // How to optimize to make this test case not to be memory exceeded AI?
  #[test]
  fn test_example_3() {
    let grid = vec![
      vec![
        '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '0',
        '1', '1',
      ],
      vec![
        '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1',
        '1', '0',
      ],
      vec![
        '1', '0', '1', '1', '1', '0', '0', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1',
        '1', '1',
      ],
      vec![
        '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',
        '1', '1',
      ],
      vec![
        '1', '0', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',
        '1', '1',
      ],
      vec![
        '1', '0', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '0', '1', '1', '1', '0', '1',
        '1', '1',
      ],
      vec![
        '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '0', '1', '1',
        '1', '1',
      ],
      vec![
        '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '0',
        '1', '1',
      ],
      vec![
        '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1',
        '1', '1',
      ],
      vec![
        '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',
        '1', '1',
      ],
      vec![
        '0', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1',
        '1', '1',
      ],
      vec![
        '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',
        '1', '1',
      ],
      vec![
        '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',
        '1', '1',
      ],
      vec![
        '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1',
        '1', '1',
      ],
      vec![
        '1', '0', '1', '1', '1', '1', '1', '0', '1', '1', '1', '0', '1', '1', '1', '1', '0', '1',
        '1', '1',
      ],
      vec![
        '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1',
        '1', '0',
      ],
      vec![
        '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1',
        '0', '0',
      ],
      vec![
        '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',
        '1', '1',
      ],
      vec![
        '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',
        '1', '1',
      ],
      vec![
        '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',
        '1', '1',
      ],
    ];
    assert_eq!(Solution::num_islands(grid), 1);
  }
}
